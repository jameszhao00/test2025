/* tslint:disable */
/* eslint-disable */
/**
 * Session-Based Chatty LLM API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ChatRequest,
  ChatResponse,
  FetchMessagesResponse,
  HTTPValidationError,
} from '../models/index';
import {
    ChatRequestFromJSON,
    ChatRequestToJSON,
    ChatResponseFromJSON,
    ChatResponseToJSON,
    FetchMessagesResponseFromJSON,
    FetchMessagesResponseToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
} from '../models/index';

export interface GetSessionMessagesApiChatSessionIdMessagesGetRequest {
    sessionId: string;
    since?: number | null;
}

export interface HandleChatApiChatPostRequest {
    chatRequest: ChatRequest;
}

export interface ServeVueAppFullPathGetRequest {
    fullPath: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Fetches messages for a given session ID, optionally filtering for messages created after a specific message ID (`since`).
     * Get Session Messages
     */
    async getSessionMessagesApiChatSessionIdMessagesGetRaw(requestParameters: GetSessionMessagesApiChatSessionIdMessagesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchMessagesResponse>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling getSessionMessagesApiChatSessionIdMessagesGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/chat/{session_id}/messages`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters['sessionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchMessagesResponseFromJSON(jsonValue));
    }

    /**
     * Fetches messages for a given session ID, optionally filtering for messages created after a specific message ID (`since`).
     * Get Session Messages
     */
    async getSessionMessagesApiChatSessionIdMessagesGet(requestParameters: GetSessionMessagesApiChatSessionIdMessagesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchMessagesResponse> {
        const response = await this.getSessionMessagesApiChatSessionIdMessagesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Handles a new user message for a chat session (existing or new). Adds the user message and a simulated assistant reply to the session history. Returns the session ID and the assistant\'s reply message.
     * Handle Chat
     */
    async handleChatApiChatPostRaw(requestParameters: HandleChatApiChatPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatResponse>> {
        if (requestParameters['chatRequest'] == null) {
            throw new runtime.RequiredError(
                'chatRequest',
                'Required parameter "chatRequest" was null or undefined when calling handleChatApiChatPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/chat`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ChatRequestToJSON(requestParameters['chatRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatResponseFromJSON(jsonValue));
    }

    /**
     * Handles a new user message for a chat session (existing or new). Adds the user message and a simulated assistant reply to the session history. Returns the session ID and the assistant\'s reply message.
     * Handle Chat
     */
    async handleChatApiChatPost(requestParameters: HandleChatApiChatPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatResponse> {
        const response = await this.handleChatApiChatPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A simple endpoint to check if the API is running.
     * Hello
     */
    async helloApiHelloGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/hello`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * A simple endpoint to check if the API is running.
     * Hello
     */
    async helloApiHelloGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.helloApiHelloGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Serves the index.html for the root path.
     * Serve Index
     */
    async serveIndexGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Serves the index.html for the root path.
     * Serve Index
     */
    async serveIndexGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.serveIndexGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Serves the Vue app for any path not matching other API routes.
     * Serve Vue App
     */
    async serveVueAppFullPathGetRaw(requestParameters: ServeVueAppFullPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['fullPath'] == null) {
            throw new runtime.RequiredError(
                'fullPath',
                'Required parameter "fullPath" was null or undefined when calling serveVueAppFullPathGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{full_path}`.replace(`{${"full_path"}}`, encodeURIComponent(String(requestParameters['fullPath']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Serves the Vue app for any path not matching other API routes.
     * Serve Vue App
     */
    async serveVueAppFullPathGet(requestParameters: ServeVueAppFullPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.serveVueAppFullPathGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
